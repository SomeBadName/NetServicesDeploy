name: Deploy Docker Service (reusable)

on:
  workflow_call:
    inputs:
      environment_name:
        type: string
        required: true
      service_name:
        type: string
        required: true
      host_port:
        type: string
        required: true
      container_port:
        type: string
        required: false
        default: "8080"
      stack_dir:
        type: string
        required: false
        default: ""
      dockerfile_path:
        type: string
        required: false
        default: "./Dockerfile"
      health_path:
        type: string
        required: false
        default: "/health"
      env_vars:
        type: string
        required: false
        default: ""
      env_secrets:
        type: string
        required: false
        default: ""

permissions:
  contents: read
  packages: write

jobs:
  build_and_deploy:
    runs-on: [self-hosted]
    environment: ${{ inputs.environment_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Compute vars
        shell: bash
        run: |
          OWNER_LC="$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')"
          SERVICE="${{ inputs.service_name }}"
          echo "SERVICE=$SERVICE" >> $GITHUB_ENV
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV
          echo "IMAGE=ghcr.io/${OWNER_LC}/${SERVICE}:latest" >> $GITHUB_ENV

          if [[ -n "${{ inputs.stack_dir }}" ]]; then
            echo "STACK_DIR=${{ inputs.stack_dir }}" >> $GITHUB_ENV
          else
            echo "STACK_DIR=/opt/stacks/${SERVICE}" >> $GITHUB_ENV
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ inputs.dockerfile_path }}
          push: true
          tags: |
            ${{ env.IMAGE }}
            ghcr.io/${{ env.OWNER_LC }}/${{ env.SERVICE }}:${{ github.sha }}

      - name: Ensure stack folder
        run: mkdir -p "${STACK_DIR}"

      - name: Write stack .env
        shell: bash
        env:
          S1: ${{ secrets.S1 }}
          S2: ${{ secrets.S2 }}
          S3: ${{ secrets.S3 }}
          S4: ${{ secrets.S4 }}
          S5: ${{ secrets.S5 }}
        run: |
          {
            echo "IMAGE=${IMAGE}"
            echo "HOST_PORT=${{ inputs.host_port }}"
            echo "CONTAINER_PORT=${{ inputs.container_port }}"

            if [[ -n "${{ inputs.env_vars }}" ]]; then
              printf '%s\n' "${{ inputs.env_vars }}"
            fi

            if [[ -n "${{ inputs.env_secrets }}" ]]; then
              while IFS= read -r line; do
                [[ -z "$line" ]] && continue
                line="${line//\$S1/$S1}"
                line="${line//\$S2/$S2}"
                line="${line//\$S3/$S3}"
                line="${line//\$S4/$S4}"
                line="${line//\$S5/$S5}"
                echo "$line"
              done <<< "${{ inputs.env_secrets }}"
            fi
          } > "${STACK_DIR}/.env"
          chmod 600 "${STACK_DIR}/.env"

      - name: Render docker-compose.yml
        shell: bash
        run: |
          cat > "${STACK_DIR}/docker-compose.yml" <<YML
          services:
            ${SERVICE}:
              image: ${IMAGE}
              container_name: ${SERVICE}
              ports:
                - "${{ inputs.host_port }}:${{ inputs.container_port }}"
              env_file:
                - .env
              environment:
                ASPNETCORE_URLS: http://0.0.0.0:${{ inputs.container_port }}
              restart: unless-stopped
          YML

      - name: Deploy
        run: |
          cd "${STACK_DIR}"
          docker compose pull
          docker compose up -d
          docker ps --filter "name=${SERVICE}"

      - name: Health check
        shell: bash
        run: |
          URL="http://127.0.0.1:${{ inputs.host_port }}${{ inputs.health_path }}"
          for i in {1..60}; do
            if curl -fsS --max-time 2 "$URL" >/dev/null; then exit 0; fi
            sleep 1
          done
          exit 1
